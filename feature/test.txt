#include <iostream>
#include <initializer_list>
#include <vector>
#include <string>
#include <map>
#include <type_traits>
#include <list>
#include <iomanip>

using namespace std;

class test
{
public:
    int row;
    int col;
    bool canUsable{true};
    int life{1};
};
void printCell(list<list<test *>> &cellss);
vector<test *> _removeCellsList;
list<list<test *>> cells;

void init(list<list<test *>> &cellsbak)
{
    int coltemp=0;
    int rowtemp=0;
    for(int i=0;i<5;++i)
    {
         list<test *> listtest;
        for(int j=0;j<7;++j)
        {
            test *t=new (std::nothrow) test;
            t->row=i;
            t->col=j;
            listtest.push_back(t);
        }
        cellsbak.push_back(listtest);
    }


    for(auto cells=cellsbak.rbegin();cells!=cellsbak.rend();++cells)
    {

        for(auto cell:*cells)
        {
            if((cell->row ==2 || cell->row==1 ) && (cell->col==2 || cell->col==3) || (cell->col==1 && cell->row==3) || (cell->col==4 && cell->row==3) ||(cell->col==2 && cell->row==4)||(cell->col==3 && cell->row==4))
            {
                cell->canUsable=false;
            }
        }

    }
    printCell(cellsbak);
}

test *searchCell(test *sourceCell,int col,int row)
{
    if(col >6 || col<0 || row>4 || row<0)
    {
        return nullptr;
    }
    else
    {
        test *dest=nullptr;
        bool getce=false;
        for(auto cellsbak:cells)
        {
            for(auto cell:cellsbak)
            {
                if(cell->row==row && cell->col==col)
                {
                    getce=true;
                    dest=cell;
                    break;
                }
            }
            if(getce==true)
            {
                break;
            }
        }

        if(dest==nullptr || (!dest->canUsable && dest->life>0))
        {
            return nullptr;
        }
        else
        {
            if(dest!=nullptr)
           _removeCellsList.push_back(dest);
            if(dest->row==4)
            {
                return dest;
            }
            dest=searchCell(sourceCell,col,row+1);
            if(dest==nullptr)
            {
                if(abs((col-1)-sourceCell->col)<=abs(col+1-sourceCell->col))
                {
                    dest=searchCell(sourceCell,col-1,row+1);
                }
                else
                {
                    dest=searchCell(sourceCell,col+1,row+1);
                }
            }

            if(dest==nullptr )
            {
                if(abs(col+1-sourceCell->col) <= abs(col-1 -sourceCell->col))
                {
                     dest=searchCell(sourceCell,col+1,row+1);
                }
                else
                {
                     dest=searchCell(sourceCell,col-1,row+1);
                }

            }

           return dest;
        }
    }

}


void printCell(list<list<test *>> &cellss)
{
    for(auto cellsbak=cellss.rbegin();cellsbak!=cellss.rend();++cellsbak)
    {

        for(auto cell:*cellsbak)
        {
            if(!cell->canUsable)
            {
                cout<<std::setw(3)<<" "<<" "<<" ";
            }
            else
            {
                cout<<std::setw(3)<<cell->col<<","<<cell->row;
            }
        }
        cout<<endl;
    }
}

test *findTheCell(int col,int row)
{
    test *dest=nullptr;
    auto getce=false;
    for(auto cellsbak:cells)
    {
        for(auto cell:cellsbak)
        {
            if(cell->row==row && cell->col==col)
            {
                getce=true;
                cell->life=0;
                dest=cell;
                break;
            }
        }
        if(getce==true)
        {
            break;
        }
    }
    return dest;
}

void printRemoveCellsList()
{
    for(auto cell:_removeCellsList)
    {
        cout<<cell->col<<" "<<cell->row<<endl;
    }
}

int main()
{

    init(cells);

    test *cell=findTheCell(3,0);

    searchCell(cell,cell->col,cell->row);
    printRemoveCellsList();


    return 0;
}

